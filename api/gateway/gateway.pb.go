// Code generated by protoc-gen-gogo.
// source: github.com/TheThingsNetwork/ttn/api/gateway/gateway.proto
// DO NOT EDIT!

/*
	Package gateway is a generated protocol buffer package.

	It is generated from these files:
		github.com/TheThingsNetwork/ttn/api/gateway/gateway.proto

	It has these top-level messages:
		GPSMetadata
		RxMetadata
		TxConfiguration
		Status
*/
package gateway

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type GPSMetadata struct {
	// Time in Unix nanoseconds
	Time      int64   `protobuf:"varint,1,opt,name=time,proto3" json:"time,omitempty"`
	Latitude  float32 `protobuf:"fixed32,2,opt,name=latitude,proto3" json:"latitude,omitempty"`
	Longitude float32 `protobuf:"fixed32,3,opt,name=longitude,proto3" json:"longitude,omitempty"`
	Altitude  int32   `protobuf:"varint,4,opt,name=altitude,proto3" json:"altitude,omitempty"`
}

func (m *GPSMetadata) Reset()                    { *m = GPSMetadata{} }
func (m *GPSMetadata) String() string            { return proto.CompactTextString(m) }
func (*GPSMetadata) ProtoMessage()               {}
func (*GPSMetadata) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{0} }

type RxMetadata struct {
	GatewayId string `protobuf:"bytes,1,opt,name=gateway_id,json=gatewayId,proto3" json:"gateway_id,omitempty"`
	// Indicates whether the gateway is trusted. Components that are able to verify gateway trust MUST do so and set this value accordingly
	GatewayTrusted bool `protobuf:"varint,2,opt,name=gateway_trusted,json=gatewayTrusted,proto3" json:"gateway_trusted,omitempty"`
	// Timestamp (uptime of LoRa module) in microseconds with rollover
	Timestamp uint32 `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Time in Unix nanoseconds
	Time    int64  `protobuf:"varint,12,opt,name=time,proto3" json:"time,omitempty"`
	RfChain uint32 `protobuf:"varint,21,opt,name=rf_chain,json=rfChain,proto3" json:"rf_chain,omitempty"`
	Channel uint32 `protobuf:"varint,22,opt,name=channel,proto3" json:"channel,omitempty"`
	// Frequency in Hz
	Frequency uint64 `protobuf:"varint,31,opt,name=frequency,proto3" json:"frequency,omitempty"`
	// Received signal strength in dBm
	Rssi float32 `protobuf:"fixed32,32,opt,name=rssi,proto3" json:"rssi,omitempty"`
	// Signal-to-noise-ratio in dB
	Snr float32      `protobuf:"fixed32,33,opt,name=snr,proto3" json:"snr,omitempty"`
	Gps *GPSMetadata `protobuf:"bytes,41,opt,name=gps" json:"gps,omitempty"`
}

func (m *RxMetadata) Reset()                    { *m = RxMetadata{} }
func (m *RxMetadata) String() string            { return proto.CompactTextString(m) }
func (*RxMetadata) ProtoMessage()               {}
func (*RxMetadata) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{1} }

func (m *RxMetadata) GetGps() *GPSMetadata {
	if m != nil {
		return m.Gps
	}
	return nil
}

type TxConfiguration struct {
	// Timestamp (uptime of LoRa module) in microseconds with rollover
	Timestamp uint32 `protobuf:"varint,11,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	RfChain   uint32 `protobuf:"varint,21,opt,name=rf_chain,json=rfChain,proto3" json:"rf_chain,omitempty"`
	// Frequency in Hz
	Frequency uint64 `protobuf:"varint,22,opt,name=frequency,proto3" json:"frequency,omitempty"`
	// Transmit power in dBm
	Power int32 `protobuf:"varint,23,opt,name=power,proto3" json:"power,omitempty"`
	// LoRa polarization inversion (basically always true for messages from gateway to node)
	PolarizationInversion bool `protobuf:"varint,31,opt,name=polarization_inversion,json=polarizationInversion,proto3" json:"polarization_inversion,omitempty"`
	// FSK frequency deviation in Hz
	FrequencyDeviation uint32 `protobuf:"varint,32,opt,name=frequency_deviation,json=frequencyDeviation,proto3" json:"frequency_deviation,omitempty"`
}

func (m *TxConfiguration) Reset()                    { *m = TxConfiguration{} }
func (m *TxConfiguration) String() string            { return proto.CompactTextString(m) }
func (*TxConfiguration) ProtoMessage()               {}
func (*TxConfiguration) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{2} }

// message Status represents a status update from a Gateway.
type Status struct {
	// Timestamp (uptime of gateway) in microseconds with rollover
	Timestamp uint32 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Time in Unix nanoseconds
	Time int64 `protobuf:"varint,2,opt,name=time,proto3" json:"time,omitempty"`
	// Indicates whether the gateway is trusted. Components that are able to verify gateway trust MUST do so and set this value accordingly
	GatewayTrusted bool     `protobuf:"varint,3,opt,name=gateway_trusted,json=gatewayTrusted,proto3" json:"gateway_trusted,omitempty"`
	Ip             []string `protobuf:"bytes,11,rep,name=ip" json:"ip,omitempty"`
	Platform       string   `protobuf:"bytes,12,opt,name=platform,proto3" json:"platform,omitempty"`
	ContactEmail   string   `protobuf:"bytes,13,opt,name=contact_email,json=contactEmail,proto3" json:"contact_email,omitempty"`
	Description    string   `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	// The gateway's region: one of EU_863_870, US_902_928, CN_779_787, EU_433, AU_915_928, CN_470_510, AS_923, KR_920_923
	Region string `protobuf:"bytes,15,opt,name=region,proto3" json:"region,omitempty"`
	// The value of Bridge is set by the Bridge
	Bridge string `protobuf:"bytes,16,opt,name=bridge,proto3" json:"bridge,omitempty"`
	// The value of Router is set by the Router
	Router string       `protobuf:"bytes,17,opt,name=router,proto3" json:"router,omitempty"`
	Gps    *GPSMetadata `protobuf:"bytes,21,opt,name=gps" json:"gps,omitempty"`
	// Round-trip time to the server in milliseconds
	Rtt uint32 `protobuf:"varint,31,opt,name=rtt,proto3" json:"rtt,omitempty"`
	// Total number of received uplink packets since boot
	RxIn uint32 `protobuf:"varint,41,opt,name=rx_in,json=rxIn,proto3" json:"rx_in,omitempty"`
	// Total number of successful (correct) uplink packets since boot
	RxOk uint32 `protobuf:"varint,42,opt,name=rx_ok,json=rxOk,proto3" json:"rx_ok,omitempty"`
	// Total number of received downlink packets since boot
	TxIn uint32 `protobuf:"varint,43,opt,name=tx_in,json=txIn,proto3" json:"tx_in,omitempty"`
	// Total number of successfully sent downlink packets since boot
	TxOk uint32            `protobuf:"varint,44,opt,name=tx_ok,json=txOk,proto3" json:"tx_ok,omitempty"`
	Os   *Status_OSMetrics `protobuf:"bytes,51,opt,name=os" json:"os,omitempty"`
}

func (m *Status) Reset()                    { *m = Status{} }
func (m *Status) String() string            { return proto.CompactTextString(m) }
func (*Status) ProtoMessage()               {}
func (*Status) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{3} }

func (m *Status) GetGps() *GPSMetadata {
	if m != nil {
		return m.Gps
	}
	return nil
}

func (m *Status) GetOs() *Status_OSMetrics {
	if m != nil {
		return m.Os
	}
	return nil
}

// Additional metrics from the operating system
type Status_OSMetrics struct {
	Load_1           float32 `protobuf:"fixed32,1,opt,name=load_1,json=load1,proto3" json:"load_1,omitempty"`
	Load_5           float32 `protobuf:"fixed32,2,opt,name=load_5,json=load5,proto3" json:"load_5,omitempty"`
	Load_15          float32 `protobuf:"fixed32,3,opt,name=load_15,json=load15,proto3" json:"load_15,omitempty"`
	CpuPercentage    float32 `protobuf:"fixed32,11,opt,name=cpu_percentage,json=cpuPercentage,proto3" json:"cpu_percentage,omitempty"`
	MemoryPercentage float32 `protobuf:"fixed32,21,opt,name=memory_percentage,json=memoryPercentage,proto3" json:"memory_percentage,omitempty"`
	Temperature      float32 `protobuf:"fixed32,31,opt,name=temperature,proto3" json:"temperature,omitempty"`
}

func (m *Status_OSMetrics) Reset()                    { *m = Status_OSMetrics{} }
func (m *Status_OSMetrics) String() string            { return proto.CompactTextString(m) }
func (*Status_OSMetrics) ProtoMessage()               {}
func (*Status_OSMetrics) Descriptor() ([]byte, []int) { return fileDescriptorGateway, []int{3, 0} }

func init() {
	proto.RegisterType((*GPSMetadata)(nil), "gateway.GPSMetadata")
	proto.RegisterType((*RxMetadata)(nil), "gateway.RxMetadata")
	proto.RegisterType((*TxConfiguration)(nil), "gateway.TxConfiguration")
	proto.RegisterType((*Status)(nil), "gateway.Status")
	proto.RegisterType((*Status_OSMetrics)(nil), "gateway.Status.OSMetrics")
}
func (m *GPSMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPSMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Time))
	}
	if m.Latitude != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Latitude))))
	}
	if m.Longitude != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Longitude))))
	}
	if m.Altitude != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Altitude))
	}
	return i, nil
}

func (m *RxMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RxMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GatewayId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.GatewayId)))
		i += copy(dAtA[i:], m.GatewayId)
	}
	if m.GatewayTrusted {
		dAtA[i] = 0x10
		i++
		if m.GatewayTrusted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Timestamp))
	}
	if m.Time != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Time))
	}
	if m.RfChain != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RfChain))
	}
	if m.Channel != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Channel))
	}
	if m.Frequency != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Frequency))
	}
	if m.Rssi != 0 {
		dAtA[i] = 0x85
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Rssi))))
	}
	if m.Snr != 0 {
		dAtA[i] = 0x8d
		i++
		dAtA[i] = 0x2
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Snr))))
	}
	if m.Gps != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Gps.Size()))
		n1, err := m.Gps.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *TxConfiguration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxConfiguration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Timestamp))
	}
	if m.RfChain != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RfChain))
	}
	if m.Frequency != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Frequency))
	}
	if m.Power != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Power))
	}
	if m.PolarizationInversion {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		if m.PolarizationInversion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.FrequencyDeviation != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.FrequencyDeviation))
	}
	return i, nil
}

func (m *Status) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Timestamp))
	}
	if m.Time != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Time))
	}
	if m.GatewayTrusted {
		dAtA[i] = 0x18
		i++
		if m.GatewayTrusted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Ip) > 0 {
		for _, s := range m.Ip {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Platform) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Platform)))
		i += copy(dAtA[i:], m.Platform)
	}
	if len(m.ContactEmail) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.ContactEmail)))
		i += copy(dAtA[i:], m.ContactEmail)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	if len(m.Bridge) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Bridge)))
		i += copy(dAtA[i:], m.Bridge)
	}
	if len(m.Router) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(len(m.Router)))
		i += copy(dAtA[i:], m.Router)
	}
	if m.Gps != nil {
		dAtA[i] = 0xaa
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Gps.Size()))
		n2, err := m.Gps.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Rtt != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Rtt))
	}
	if m.RxIn != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RxIn))
	}
	if m.RxOk != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.RxOk))
	}
	if m.TxIn != 0 {
		dAtA[i] = 0xd8
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.TxIn))
	}
	if m.TxOk != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x2
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.TxOk))
	}
	if m.Os != nil {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintGateway(dAtA, i, uint64(m.Os.Size()))
		n3, err := m.Os.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *Status_OSMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Status_OSMetrics) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Load_1 != 0 {
		dAtA[i] = 0xd
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Load_1))))
	}
	if m.Load_5 != 0 {
		dAtA[i] = 0x15
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Load_5))))
	}
	if m.Load_15 != 0 {
		dAtA[i] = 0x1d
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Load_15))))
	}
	if m.CpuPercentage != 0 {
		dAtA[i] = 0x5d
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.CpuPercentage))))
	}
	if m.MemoryPercentage != 0 {
		dAtA[i] = 0xad
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.MemoryPercentage))))
	}
	if m.Temperature != 0 {
		dAtA[i] = 0xfd
		i++
		dAtA[i] = 0x1
		i++
		i = encodeFixed32Gateway(dAtA, i, uint32(math.Float32bits(float32(m.Temperature))))
	}
	return i, nil
}

func encodeFixed64Gateway(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Gateway(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintGateway(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *GPSMetadata) Size() (n int) {
	var l int
	_ = l
	if m.Time != 0 {
		n += 1 + sovGateway(uint64(m.Time))
	}
	if m.Latitude != 0 {
		n += 5
	}
	if m.Longitude != 0 {
		n += 5
	}
	if m.Altitude != 0 {
		n += 1 + sovGateway(uint64(m.Altitude))
	}
	return n
}

func (m *RxMetadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.GatewayId)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	if m.GatewayTrusted {
		n += 2
	}
	if m.Timestamp != 0 {
		n += 1 + sovGateway(uint64(m.Timestamp))
	}
	if m.Time != 0 {
		n += 1 + sovGateway(uint64(m.Time))
	}
	if m.RfChain != 0 {
		n += 2 + sovGateway(uint64(m.RfChain))
	}
	if m.Channel != 0 {
		n += 2 + sovGateway(uint64(m.Channel))
	}
	if m.Frequency != 0 {
		n += 2 + sovGateway(uint64(m.Frequency))
	}
	if m.Rssi != 0 {
		n += 6
	}
	if m.Snr != 0 {
		n += 6
	}
	if m.Gps != nil {
		l = m.Gps.Size()
		n += 2 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *TxConfiguration) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGateway(uint64(m.Timestamp))
	}
	if m.RfChain != 0 {
		n += 2 + sovGateway(uint64(m.RfChain))
	}
	if m.Frequency != 0 {
		n += 2 + sovGateway(uint64(m.Frequency))
	}
	if m.Power != 0 {
		n += 2 + sovGateway(uint64(m.Power))
	}
	if m.PolarizationInversion {
		n += 3
	}
	if m.FrequencyDeviation != 0 {
		n += 2 + sovGateway(uint64(m.FrequencyDeviation))
	}
	return n
}

func (m *Status) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovGateway(uint64(m.Timestamp))
	}
	if m.Time != 0 {
		n += 1 + sovGateway(uint64(m.Time))
	}
	if m.GatewayTrusted {
		n += 2
	}
	if len(m.Ip) > 0 {
		for _, s := range m.Ip {
			l = len(s)
			n += 1 + l + sovGateway(uint64(l))
		}
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.ContactEmail)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovGateway(uint64(l))
	}
	l = len(m.Bridge)
	if l > 0 {
		n += 2 + l + sovGateway(uint64(l))
	}
	l = len(m.Router)
	if l > 0 {
		n += 2 + l + sovGateway(uint64(l))
	}
	if m.Gps != nil {
		l = m.Gps.Size()
		n += 2 + l + sovGateway(uint64(l))
	}
	if m.Rtt != 0 {
		n += 2 + sovGateway(uint64(m.Rtt))
	}
	if m.RxIn != 0 {
		n += 2 + sovGateway(uint64(m.RxIn))
	}
	if m.RxOk != 0 {
		n += 2 + sovGateway(uint64(m.RxOk))
	}
	if m.TxIn != 0 {
		n += 2 + sovGateway(uint64(m.TxIn))
	}
	if m.TxOk != 0 {
		n += 2 + sovGateway(uint64(m.TxOk))
	}
	if m.Os != nil {
		l = m.Os.Size()
		n += 2 + l + sovGateway(uint64(l))
	}
	return n
}

func (m *Status_OSMetrics) Size() (n int) {
	var l int
	_ = l
	if m.Load_1 != 0 {
		n += 5
	}
	if m.Load_5 != 0 {
		n += 5
	}
	if m.Load_15 != 0 {
		n += 5
	}
	if m.CpuPercentage != 0 {
		n += 5
	}
	if m.MemoryPercentage != 0 {
		n += 6
	}
	if m.Temperature != 0 {
		n += 6
	}
	return n
}

func sovGateway(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozGateway(x uint64) (n int) {
	return sovGateway(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *GPSMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPSMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPSMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Latitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Latitude = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Longitude", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Longitude = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Altitude", wireType)
			}
			m.Altitude = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Altitude |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RxMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RxMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RxMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GatewayId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayTrusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GatewayTrusted = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfChain", wireType)
			}
			m.RfChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfChain |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rssi", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Rssi = float32(math.Float32frombits(v))
		case 33:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snr", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Snr = float32(math.Float32frombits(v))
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gps == nil {
				m.Gps = &GPSMetadata{}
			}
			if err := m.Gps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxConfiguration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxConfiguration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxConfiguration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RfChain", wireType)
			}
			m.RfChain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RfChain |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Power", wireType)
			}
			m.Power = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Power |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PolarizationInversion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PolarizationInversion = bool(v != 0)
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrequencyDeviation", wireType)
			}
			m.FrequencyDeviation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrequencyDeviation |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Status: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Status: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GatewayTrusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GatewayTrusted = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = append(m.Ip, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactEmail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactEmail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bridge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bridge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Router", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Router = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gps == nil {
				m.Gps = &GPSMetadata{}
			}
			if err := m.Gps.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rtt", wireType)
			}
			m.Rtt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rtt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxIn", wireType)
			}
			m.RxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxIn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxOk", wireType)
			}
			m.RxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RxOk |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxIn", wireType)
			}
			m.TxIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxIn |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxOk", wireType)
			}
			m.TxOk = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxOk |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Os", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGateway
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Os == nil {
				m.Os = &Status_OSMetrics{}
			}
			if err := m.Os.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Status_OSMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OSMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OSMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Load_1 = float32(math.Float32frombits(v))
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_5", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Load_5 = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Load_15", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Load_15 = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.CpuPercentage = float32(math.Float32frombits(v))
		case 21:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryPercentage", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.MemoryPercentage = float32(math.Float32frombits(v))
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Temperature", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Temperature = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipGateway(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGateway
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGateway(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGateway
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGateway
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthGateway
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowGateway
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipGateway(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthGateway = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGateway   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/TheThingsNetwork/ttn/api/gateway/gateway.proto", fileDescriptorGateway)
}

var fileDescriptorGateway = []byte{
	// 756 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x54, 0x4f, 0x93, 0xdb, 0x34,
	0x14, 0xc7, 0xce, 0xe6, 0x9f, 0xd2, 0x64, 0xb7, 0x6a, 0x93, 0xaa, 0x3b, 0x10, 0x4c, 0x18, 0x20,
	0x65, 0x21, 0x99, 0xa5, 0x93, 0x03, 0x07, 0x2e, 0x14, 0x86, 0xd9, 0x03, 0x6c, 0x47, 0xcd, 0x89,
	0x8b, 0x47, 0xb1, 0x15, 0x47, 0x13, 0x5b, 0x32, 0xb2, 0xdc, 0x64, 0xf9, 0x24, 0x9c, 0xb9, 0xf0,
	0x55, 0x7a, 0xe4, 0x23, 0x30, 0xcb, 0x0c, 0x9f, 0x83, 0xd1, 0xf3, 0x9f, 0x75, 0x99, 0x42, 0x87,
	0x53, 0xde, 0xef, 0x8f, 0xfc, 0xde, 0xd3, 0x7b, 0x11, 0xfa, 0x32, 0x12, 0x66, 0x97, 0x6f, 0x16,
	0x81, 0x4a, 0x96, 0xeb, 0x1d, 0x5f, 0xef, 0x84, 0x8c, 0xb2, 0x1f, 0xb8, 0x39, 0x28, 0xbd, 0x5f,
	0x1a, 0x23, 0x97, 0x2c, 0x15, 0xcb, 0x88, 0x19, 0x7e, 0x60, 0x37, 0xd5, 0xef, 0x22, 0xd5, 0xca,
	0x28, 0xdc, 0x2d, 0xe1, 0xf9, 0xe7, 0x8d, 0x6f, 0x44, 0x2a, 0x52, 0x4b, 0xd0, 0x37, 0xf9, 0x16,
	0x10, 0x00, 0x88, 0x8a, 0x73, 0xb3, 0x03, 0x1a, 0x7c, 0xf7, 0xfc, 0xc5, 0xf7, 0xdc, 0xb0, 0x90,
	0x19, 0x86, 0x31, 0x3a, 0x31, 0x22, 0xe1, 0xc4, 0xf1, 0x9c, 0x79, 0x8b, 0x42, 0x8c, 0xcf, 0x51,
	0x2f, 0x66, 0x46, 0x98, 0x3c, 0xe4, 0xc4, 0xf5, 0x9c, 0xb9, 0x4b, 0x6b, 0x8c, 0xdf, 0x45, 0xfd,
	0x58, 0xc9, 0xa8, 0x10, 0x5b, 0x20, 0xde, 0x11, 0xf6, 0x24, 0x8b, 0xcb, 0x93, 0x27, 0x9e, 0x33,
	0x6f, 0xd3, 0x1a, 0xcf, 0x7e, 0x73, 0x11, 0xa2, 0xc7, 0x3a, 0xf1, 0x7b, 0x08, 0x95, 0x1d, 0xf8,
	0x22, 0x84, 0xf4, 0x7d, 0xda, 0x2f, 0x99, 0xab, 0x10, 0x7f, 0x82, 0x4e, 0x2b, 0xd9, 0xe8, 0x3c,
	0x33, 0x3c, 0x84, 0x52, 0x7a, 0x74, 0x54, 0xd2, 0xeb, 0x82, 0xb5, 0x05, 0xd9, 0xa2, 0x33, 0xc3,
	0x92, 0x94, 0x0c, 0x3c, 0x67, 0x3e, 0xa4, 0x77, 0x44, 0xdd, 0xde, 0xbd, 0x46, 0x7b, 0x8f, 0x51,
	0x4f, 0x6f, 0xfd, 0x60, 0xc7, 0x84, 0x24, 0x63, 0x38, 0xd0, 0xd5, 0xdb, 0x67, 0x16, 0x62, 0x82,
	0xba, 0xc1, 0x8e, 0x49, 0xc9, 0x63, 0x32, 0x29, 0x94, 0x12, 0xda, 0x34, 0x5b, 0xcd, 0x7f, 0xca,
	0xb9, 0x0c, 0x6e, 0xc8, 0xfb, 0x9e, 0x33, 0x3f, 0xa1, 0x77, 0x84, 0x4d, 0xa3, 0xb3, 0x4c, 0x10,
	0x0f, 0x2e, 0x04, 0x62, 0x7c, 0x86, 0x5a, 0x99, 0xd4, 0xe4, 0x03, 0xa0, 0x6c, 0x88, 0x3f, 0x46,
	0xad, 0x28, 0xcd, 0xc8, 0x13, 0xcf, 0x99, 0x0f, 0xbe, 0x78, 0xb8, 0xa8, 0xe6, 0xd9, 0x18, 0x07,
	0xb5, 0x86, 0xd9, 0x5f, 0x0e, 0x3a, 0x5d, 0x1f, 0x9f, 0x29, 0xb9, 0x15, 0x51, 0xae, 0x99, 0x11,
	0x4a, 0xbe, 0xa5, 0xcd, 0xff, 0x68, 0xe9, 0xb5, 0xc2, 0x27, 0xff, 0x2c, 0xfc, 0x21, 0x6a, 0xa7,
	0xea, 0xc0, 0x35, 0x79, 0x04, 0xd3, 0x2a, 0x00, 0x5e, 0xa1, 0x49, 0xaa, 0x62, 0xa6, 0xc5, 0xcf,
	0x90, 0xdc, 0x17, 0xf2, 0x25, 0xd7, 0x99, 0x50, 0x12, 0x3a, 0xef, 0xd1, 0x71, 0x53, 0xbd, 0xaa,
	0x44, 0xbc, 0x44, 0x0f, 0xea, 0x2f, 0xfb, 0x21, 0x7f, 0x29, 0x40, 0x87, 0x4b, 0x19, 0x52, 0x5c,
	0x4b, 0xdf, 0x54, 0xca, 0xec, 0xd7, 0x36, 0xea, 0xbc, 0x30, 0xcc, 0xe4, 0xd9, 0xeb, 0xfd, 0x39,
	0xff, 0x36, 0x46, 0xb7, 0x31, 0xc6, 0x37, 0x6c, 0x48, 0xeb, 0x8d, 0x1b, 0x32, 0x42, 0xae, 0xb0,
	0x77, 0xd6, 0x9a, 0xf7, 0xa9, 0x2b, 0x52, 0xbb, 0xa4, 0x69, 0xcc, 0xcc, 0x56, 0xe9, 0x04, 0xf6,
	0xa2, 0x4f, 0x6b, 0x8c, 0x3f, 0x44, 0xc3, 0x40, 0x49, 0xc3, 0x02, 0xe3, 0xf3, 0x84, 0x89, 0x98,
	0x0c, 0xc1, 0x70, 0xaf, 0x24, 0xbf, 0xb5, 0x1c, 0xf6, 0xd0, 0x20, 0xe4, 0x59, 0xa0, 0x45, 0x0a,
	0xfd, 0x8d, 0xc0, 0xd2, 0xa4, 0xf0, 0x04, 0x75, 0x34, 0x8f, 0xac, 0x78, 0x0a, 0x62, 0x89, 0x2c,
	0xbf, 0xd1, 0x22, 0x8c, 0x38, 0x39, 0x2b, 0xf8, 0x02, 0x81, 0x5f, 0xe5, 0x86, 0x6b, 0x72, 0xbf,
	0xf4, 0x03, 0xaa, 0x36, 0x66, 0xfc, 0x96, 0x8d, 0xb1, 0xbb, 0xa6, 0x8d, 0x81, 0xe9, 0x0c, 0xa9,
	0x0d, 0xf1, 0x03, 0xd4, 0xd6, 0x47, 0x5f, 0x48, 0xd8, 0xb6, 0x21, 0x3d, 0xd1, 0xc7, 0x2b, 0x59,
	0x92, 0x6a, 0x4f, 0x3e, 0xad, 0xc8, 0xeb, 0xbd, 0x25, 0x0d, 0x38, 0x2f, 0x0a, 0xd2, 0x94, 0x4e,
	0x03, 0xce, 0xcf, 0x2a, 0xf2, 0x7a, 0x8f, 0x9f, 0x20, 0x57, 0x65, 0xe4, 0x29, 0x14, 0xf3, 0xb8,
	0x2e, 0xa6, 0x18, 0xe0, 0xe2, 0xda, 0x96, 0xa4, 0x45, 0x90, 0x51, 0x57, 0x65, 0xe7, 0xaf, 0x1c,
	0xd4, 0xaf, 0x19, 0x3c, 0x46, 0x9d, 0x58, 0xb1, 0xd0, 0xbf, 0x84, 0xc9, 0xba, 0xb4, 0x6d, 0xd1,
	0x65, 0x4d, 0xaf, 0xca, 0x57, 0x06, 0xe8, 0x15, 0x7e, 0x84, 0xba, 0x85, 0x7b, 0x55, 0x3e, 0x30,
	0xe0, 0xba, 0x5c, 0xe1, 0x8f, 0xd0, 0x28, 0x48, 0x73, 0x3f, 0xe5, 0x3a, 0xe0, 0xd2, 0xb0, 0x88,
	0xc3, 0x1f, 0xc1, 0xa5, 0xc3, 0x20, 0xcd, 0x9f, 0xd7, 0x24, 0xbe, 0x40, 0xf7, 0x13, 0x9e, 0x28,
	0x7d, 0xd3, 0x74, 0x8e, 0xc1, 0x79, 0x56, 0x08, 0x0d, 0xb3, 0x87, 0x06, 0x86, 0x27, 0x29, 0xd7,
	0xcc, 0xe4, 0x9a, 0xc3, 0x0d, 0xba, 0xb4, 0x49, 0x7d, 0xfd, 0xd5, 0xab, 0xdb, 0xa9, 0xf3, 0xfb,
	0xed, 0xd4, 0xf9, 0xe3, 0x76, 0xea, 0xfc, 0xf2, 0xe7, 0xf4, 0x9d, 0x1f, 0x2f, 0xfe, 0xc7, 0xab,
	0xbd, 0xe9, 0xc0, 0xb3, 0xfb, 0xf4, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x44, 0x16, 0x88, 0x7b,
	0xeb, 0x05, 0x00, 0x00,
}
